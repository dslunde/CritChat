import 'package:flutter/foundation.dart';
import 'package:critchat/features/characters/domain/entities/character_entity.dart';
import 'package:critchat/features/characters/domain/entities/character_memory_entity.dart';
import 'package:critchat/features/characters/domain/repositories/character_memory_repository.dart';
import 'package:critchat/core/chat/chat_realtime_datasource.dart';
import 'package:critchat/core/llm/llm_service.dart';

abstract class RagService {
  /// Generate a character response based on the character's personality and context
  Future<String> generateCharacterResponse({
    required CharacterEntity character,
    required String userPrompt,
    required List<Message> recentContext,
  });

  /// Store a memory for a character
  Future<CharacterMemoryEntity> storeCharacterMemory({
    required String characterId,
    required String userId,
    required String content,
    Map<String, dynamic>? metadata,
    String? source,
  });

  /// Index a character's basic information in the vector database
  Future<void> indexCharacter(CharacterEntity character);

  /// Update character index when character is modified
  Future<void> updateCharacterIndex(CharacterEntity character);

  /// Remove character from index when deleted
  Future<void> removeCharacterIndex(String characterId);

  /// Get all memories for a character
  Future<List<CharacterMemoryEntity>> getCharacterMemories(String characterId);

  /// Check if the RAG system is fully operational
  Future<bool> isOperational();
}

class RagServiceImpl implements RagService {
  final CharacterMemoryRepository? _memoryRepository;
  final LlmService? _llmService;

  RagServiceImpl({
    CharacterMemoryRepository? memoryRepository,
    LlmService? llmService,
  }) : _memoryRepository = memoryRepository,
       _llmService = llmService;

  @override
  Future<String> generateCharacterResponse({
    required CharacterEntity character,
    required String userPrompt,
    required List<Message> recentContext,
  }) async {
    try {
      // Check if we have the full RAG system available
      if (_memoryRepository != null && _llmService != null) {
        return await _generateEnhancedCharacterResponse(
          character,
          userPrompt,
          recentContext,
        );
      } else {
        // Fall back to simple response generation
        return await _generateSimpleCharacterResponse(character, userPrompt, recentContext);
      }
    } catch (e) {
      debugPrint('‚ùå RAG response generation failed, falling back to simple response: $e');
      // Always fall back to simple generation if anything fails
      return await _generateSimpleCharacterResponse(character, userPrompt, recentContext);
    }
  }

  @override
  Future<CharacterMemoryEntity> storeCharacterMemory({
    required String characterId,
    required String userId,
    required String content,
    Map<String, dynamic>? metadata,
    String? source,
  }) async {
    if (_memoryRepository == null) {
      throw Exception('Memory repository not available');
    }

    try {
      final now = DateTime.now();
      final memory = CharacterMemoryEntity(
        id: '', // Will be generated by repository
        characterId: characterId,
        userId: userId,
        content: content,
        embedding: [], // Will be generated by repository
        metadata: metadata ?? {},
        source: source,
        createdAt: now,
        updatedAt: now,
      );

      final storedMemory = await _memoryRepository.storeMemory(memory);
      debugPrint('‚úÖ Stored character memory: ${storedMemory.id}');
      return storedMemory;
    } catch (e) {
      debugPrint('‚ùå Failed to store character memory: $e');
      throw Exception('Failed to store character memory: $e');
    }
  }

  @override
  Future<void> indexCharacter(CharacterEntity character) async {
    try {
      if (_memoryRepository == null) {
        debugPrint('üìö Memory repository not available for indexing: ${character.name}');
        return;
      }

      // Index each piece of character information as separate memories
      final indexableContent = character.getIndexableContent();
      
      debugPrint('üìö Indexing character: ${character.name} with ${indexableContent.length} content pieces');

      for (final content in indexableContent) {
        try {
          await storeCharacterMemory(
            characterId: character.id,
            userId: character.userId,
            content: content,
            metadata: {'type': 'character_profile', 'indexed_at': DateTime.now().toIso8601String()},
            source: 'character_profile',
          );
        } catch (e) {
          debugPrint('‚ö†Ô∏è Failed to index content piece: $content - $e');
          // Continue indexing other pieces even if one fails
        }
      }

      debugPrint('‚úÖ Finished indexing character: ${character.name}');
    } catch (e) {
      debugPrint('‚ùå Failed to index character: $e');
      throw Exception('Failed to index character: $e');
    }
  }

  @override
  Future<void> updateCharacterIndex(CharacterEntity character) async {
    try {
      debugPrint('üîÑ Updating character index: ${character.name}');
      
      // For character updates, we'll remove old profile memories and re-index
      if (_memoryRepository != null) {
        // Get all memories for this character
        final memories = await _memoryRepository.getCharacterMemories(character.id);
        
        // Remove old character profile memories
        final profileMemories = memories.where(
          (m) => m.metadata['type'] == 'character_profile',
        );
        
        for (final memory in profileMemories) {
          try {
            await _memoryRepository.deleteMemory(memory.id);
          } catch (e) {
            debugPrint('‚ö†Ô∏è Failed to delete old profile memory: ${memory.id} - $e');
          }
        }
        
        // Re-index with updated character information
        await indexCharacter(character);
      }
      
      debugPrint('‚úÖ Updated character index: ${character.name}');
    } catch (e) {
      debugPrint('‚ùå Failed to update character index: $e');
      throw Exception('Failed to update character index: $e');
    }
  }

  @override
  Future<void> removeCharacterIndex(String characterId) async {
    try {
      if (_memoryRepository == null) {
        debugPrint('üóëÔ∏è Memory repository not available for removal: $characterId');
        return;
      }

      await _memoryRepository.deleteAllCharacterMemories(characterId);
      debugPrint('‚úÖ Removed character index: $characterId');
    } catch (e) {
      debugPrint('‚ùå Failed to remove character index: $e');
      throw Exception('Failed to remove character index: $e');
    }
  }

  @override
  Future<List<CharacterMemoryEntity>> getCharacterMemories(String characterId) async {
    if (_memoryRepository == null) {
      return [];
    }

    try {
      return await _memoryRepository.getCharacterMemories(characterId);
    } catch (e) {
      debugPrint('‚ùå Failed to get character memories: $e');
      return [];
    }
  }

  @override
  Future<bool> isOperational() async {
    try {
      final memoryHealthy = _memoryRepository?.isVectorDatabaseHealthy() ?? Future.value(false);
      final llmHealthy = _llmService?.isAvailable() ?? Future.value(false);
      
      final results = await Future.wait([memoryHealthy, llmHealthy]);
      
      return results[0] && results[1];
    } catch (e) {
      debugPrint('üîç RAG system health check failed: $e');
      return false;
    }
  }

  /// Enhanced character response generation using vector search + LLM
  Future<String> _generateEnhancedCharacterResponse(
    CharacterEntity character,
    String userPrompt,
    List<Message> recentContext,
  ) async {
    try {
      debugPrint('üöÄ Generating enhanced character response for: ${character.name}');

      // Search for relevant memories based on the user prompt
      final relevantMemories = await _memoryRepository!.searchMemoriesByText(
        characterId: character.id,
        query: userPrompt,
        limit: 10,
        minSimilarity: 0.1,
      );

      debugPrint('üìä Found ${relevantMemories.length} relevant memories');

      // Generate response using LLM with retrieved context
      final response = await _llmService!.generateCharacterResponse(
        character: character,
        userPrompt: userPrompt,
        relevantMemories: relevantMemories,
        recentContext: recentContext,
      );

      debugPrint('‚úÖ Enhanced response generated successfully');
      return response;
    } catch (e) {
      debugPrint('‚ùå Enhanced response generation failed: $e');
      rethrow;
    }
  }

  /// Simple character response generation (placeholder until full RAG is implemented)
  Future<String> _generateSimpleCharacterResponse(
    CharacterEntity character,
    String userPrompt,
    List<Message> recentContext,
  ) async {
    // Create a character-appropriate response based on personality and speech patterns
    final response = _craftCharacterResponse(character, userPrompt);
    
    // Add some delay to simulate LLM processing
    await Future.delayed(const Duration(milliseconds: 500));
    
    return response;
  }

  String _craftCharacterResponse(CharacterEntity character, String userPrompt) {
    // Analyze the character's personality and speech patterns
    final personality = character.personality.toLowerCase();
    final speechPatterns = character.speechPatterns.toLowerCase();
    final isPromptQuestion = userPrompt.trim().endsWith('?');
    
    // Build response based on character traits
    String response = '';
    
    // Add character-appropriate greeting or acknowledgment
    if (personality.contains('confident') || personality.contains('bold')) {
      response = isPromptQuestion ? 'Absolutely! ' : 'Listen well - ';
    } else if (personality.contains('mysterious') || personality.contains('secretive')) {
      response = isPromptQuestion ? 'Perhaps... ' : 'In shadows I speak: ';
    } else if (personality.contains('wise') || personality.contains('learned')) {
      response = isPromptQuestion ? 'Indeed, ' : 'As I have observed, ';
    } else if (personality.contains('cheerful') || personality.contains('optimistic')) {
      response = isPromptQuestion ? 'Oh yes! ' : 'With joy I say: ';
    } else {
      response = isPromptQuestion ? 'Well, ' : '';
    }
    
    // Add the core message, modified by speech patterns
    String coreMessage = userPrompt;
    
    // Modify based on speech patterns
    if (speechPatterns.contains('formal') || speechPatterns.contains('eloquent')) {
      coreMessage = _makeMoreFormal(coreMessage);
    } else if (speechPatterns.contains('casual') || speechPatterns.contains('slang')) {
      coreMessage = _makeCasual(coreMessage);
    } else if (speechPatterns.contains('archaic') || speechPatterns.contains('old')) {
      coreMessage = _makeArchaic(coreMessage);
    }
    
    response += coreMessage;
    
    // Add character-appropriate ending
    if (speechPatterns.contains('dramatic')) {
      response += '!';
    } else if (personality.contains('mysterious')) {
      response += '...';
    } else if (personality.contains('wise')) {
      response += ', as experience has taught me.';
    }
    
    return response;
  }

  String _makeMoreFormal(String text) {
    return text
        .replaceAll(RegExp(r"\bcan't\b"), 'cannot')
        .replaceAll(RegExp(r"\bwon't\b"), 'will not')
        .replaceAll(RegExp(r"\bdon't\b"), 'do not')
        .replaceAll(RegExp(r"\bisn't\b"), 'is not');
  }

  String _makeCasual(String text) {
    return text
        .replaceAll(RegExp(r'\bcannot\b'), "can't")
        .replaceAll(RegExp(r'\bwill not\b'), "won't")
        .replaceAll(RegExp(r'\bdo not\b'), "don't");
  }

  String _makeArchaic(String text) {
    return text
        .replaceAll(RegExp(r'\byou\b'), 'thee')
        .replaceAll(RegExp(r'\byour\b'), 'thy')
        .replaceAll(RegExp(r'\bare\b'), 'art');
  }
} 